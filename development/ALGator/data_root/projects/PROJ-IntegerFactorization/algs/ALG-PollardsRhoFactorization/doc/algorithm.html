<html>
<p>Let \(n = p\cdot m\) where \(p\) is a prime number and \(m\) an integer which does not need to be a prime number. Our task
    is to find \(p\). Now
    <b>Pollard's rho algorithm</b> uses the fact: if \(x_1 = x_2\; (\text{mod }p);\ x_1, x_2\) from \(\{0,...,n-1\}\), then
    \(p|(x_1 - x_2)\). We know that \(p|n\) and \(p| (x_1 - x_2)\), therefore \(p | \text{gcd}(x_1 - x_2, n)\). We do not
    know the value of \(p\) but we could calculate \(\text{gcd}(x_i - x_j, n)\) for \(1 \leq i &lt; j \leq l\) and eventually
    find nontrivial divisor of number n. Now we have to find \(x_i\) and \(x_j\), such that \(x_i=x _j\; (\text{mod }p)\).
    We make two sequences; the first steps forward for the step of length one, and the second for the step of length two.
    Mathematically we would write the sequences as:</p>
<p>\(s_1 : x_0, x_1=f(x_0), x_2 = f(x_1),...;\ f = x^2 + 1 (mod n) \)</p>
<p>\(s_2 : y_0, y_1=f(f(y_0)), y_2 = f(f(y_1)),...;\ f = x^2 + 1 (mod n) \)</p>
<p>We assume that at some point both sequences are in a cycle, from that point forward is just a metter of time until one sequence
    catches the other. </p>
<p>Simple pseudocode:</p>

<ol>
    <li>
        <b>function PollardRhoFactorization(\(N\))</b>
    </li>
    <li>&emsp; \(x_i := 2\)</li>
    <li>&emsp; \(y_i := 2\)</li>
    <li>
        <b>&emsp; while (true)</b>
    </li>
    <li>&emsp;&emsp; \(x_i := (x_i ^ 2 + 1) (\text{mod } N) \)</li>
    <li>&emsp;&emsp; \(y_i := ((y_i ^ 2 + 1) ^ 2 + 1) (\text{mod } N)\)</li>

    <li>&emsp;&emsp; \(s := \text{gcd}(x_i - y_i, N)\)</li>
    <li>&emsp;&emsp;
        <b>if</b> \(s != 1\)
        <b>and</b> \(s != N\)
        <b>then</b>
    </li>
    <li>&emsp;&emsp;&emsp;
        <b>return</b> \(s, N/s\)</li>
</ol>

</html>